[
	[
		"trading_enums.ExchangeTypes.SPOT,\n            trading_enums.ExchangeTypes.FUTURE,\n        ]\n\n    def get_current_state(self) -> (str, float):\n        return super().get_current_state()[0] if self.producers[0].state is None else self.producers[0].state.name, \n               self.producers[0].final_eval\n\n    def get_mode_producer_classes(self) -> list:\n        return [TrailingStopModeProducer]\n\n    def get_mode_consumer_classes(self) -> list:\n        return [TrailingStopModeConsumer]\n\n    @classmethod\n    def get_is_symbol_wildcard(cls) -> bool:\n        return False\n\n\nclass TrailingStopModeConsumer(trading_modes.AbstractTradingModeConsumer):\n    def __init__(self, trading_mode):\n        super().__init__(trading_mode)\n        self.trader = self.exchange_manager.trader\n\n    def flush(self):\n        super().flush()\n        self.trader = None\n\n    async def create_new_orders(self, symbol, final_note, state, **kwargs):\n        # This trading mode doesn't create new orders based on signals\n        # It manages existing positions with trailing stops\n        return []\n\n\nclass TrailingStopModeProducer(trading_modes.AbstractTradingModeProducer):\n    def __init__(self, channel, config, trading_mode, exchange_manager):\n        super().__init__(channel, config, trading_mode, exchange_manager)\n\n        self.state = None\n        self.final_eval = trading_constants.ZERO\n\n        # Configuration\n        self.atr_period = self.trading_mode.trading_config.get(\"atr_period",
		14,
		"self.atr_multiplier = decimal.Decimal(str(self.trading_mode.trading_config.get(\"atr_multiplier",
		2,
		"self.profit_tiers = self.trading_mode.trading_config.get(\"profit_tiers",
		[],
		"self.partial_take_profit_percentages = self.trading_mode.trading_config.get(\"partial_take_profit_percentages",
		[],
		"self.partial_take_profit_r_multiples = self.trading_mode.trading_config.get(\"partial_take_profit_r_multiples",
		[],
		"self.break_even_r_multiple = decimal.Decimal(str(self.trading_mode.trading_config.get(\"break_even_r_multiple",
		0.5,
		"self.max_trade_duration_bars = self.trading_mode.trading_config.get(\"max_trade_duration_bars",
		24,
		"self.enable_trend_filter = self.trading_mode.trading_config.get(\"enable_trend_filter",
		true,
		"self.enable_volatility_filter = self.trading_mode.trading_config.get(\"enable_volatility_filter",
		true,
		"self.enable_momentum_filter = self.trading_mode.trading_config.get(\"enable_momentum_filter",
		true,
		"Runtime data\n        self.position_entry_times = {}  # Track when positions were entered\n        self.position_max_r_values = {}  # Track maximum R values reached\n        self.position_locked_quantities = {}  # Track locked quantities for partial take profits\n\n    async def stop(self):\n        if self.trading_mode is not None:\n            self.trading_mode.flush_trading_mode_consumers()\n        await super().stop()\n\n    async def set_final_eval(self, matrix_id: str, cryptocurrency: str, symbol: str, time_frame, trigger_source: str):\n        # For this mode, we don't use matrix evaluations for order creation\n        # Instead, we monitor open positions and adjust trailing stops\n        await self.manage_open_positions(symbol)\n\n    async def manage_open_positions(self, symbol: str):\n        \"",
		"\n        Manage open positions by adjusting trailing stops based on ATR and other factors\n        \"",
		"\n        # Get open positions for the symbol\n        positions = self.exchange_manager.exchange_personal_data.positions_manager.get_symbol_positions(symbol)\n        \n        for position in positions:\n            if not position.is_idle():\n                await self.adjust_trailing_stop(position)\n\n    async def adjust_trailing_stop(self, position):\n        \"",
		"\n        Adjust trailing stop for a position based on ATR and profit tiers\n        \"",
		"\n        try:\n            symbol = position.symbol\n            # Get current price\n            current_price = await trading_personal_data.get_up_to_date_price(\n                self.exchange_manager, symbol, timeout=trading_constants.ORDER_DATA_FETCHING_TIMEOUT\n            )\n            \n            # Calculate ATR for stop distance\n            stop_distance = await self.calculate_atr_stop_distance(symbol, current_price)\n            \n            # Get position entry price\n            entry_price = position.entry_price\n            \n            # Calculate current profit/loss in R multiples\n            r_value = self.calculate_r_value(position, entry_price, stop_distance)\n            current_r = self.calculate_current_r(position, entry_price, current_price, r_value)\n            \n            # Update maximum R value reached for this position\n            position_id = position.get_id()\n            if position_id not in self.position_max_r_values:\n                self.position_max_r_values[position_id] = decimal.Decimal('0')\n            \n            if current_r > self.position_max_r_values[position_id]:\n                self.position_max_r_values[position_id] = current_r\n            \n            # Determine new stop price based on profit tiers and current R value\n            new_stop_price = self.calculate_trailing_stop_price(position, current_price, stop_distance, current_r)\n            \n            # Check if we should take partial profits\n            await self.check_partial_take_profits(position, current_price, current_r)\n            \n            # Check if we should adjust to break-even\n            await self.check_break_even_adjustment(position, current_r, stop_distance)\n            \n            # Check if trade duration has exceeded maximum\n            await self.check_trade_duration(position, symbol)\n            \n            # Adjust stop-loss order if needed\n            await self.update_stop_loss_order(position, new_stop_price)\n            \n        except Exception as e:\n            self.logger.exception(e, True, f\"Error adjusting trailing stop for position {position}: {e}",
		"async def calculate_atr_stop_distance(self, symbol, current_price):\n        \"",
		"\n        Calculate stop distance based on ATR\n        \"",
		"\n        try:\n            # Get OHLCV data for ATR calculation\n            exchange_symbol_data = self.get_exchange_symbol_data(self.exchange_name, self.exchange_manager.id, symbol)\n            high = trading_api.get_symbol_high_candles(exchange_symbol_data, self.exchange_manager.exchange_config.get_shortest_time_frame(),\n                                                       include_in_construction=False)\n            low = trading_api.get_symbol_low_candles(exchange_symbol_data, self.exchange_manager.exchange_config.get_shortest_time_frame(),\n                                                    include_in_construction=False)\n            close = trading_api.get_symbol_close_candles(exchange_symbol_data, self.exchange_manager.exchange_config.get_shortest_time_frame(),\n                                                         include_in_construction=False)\n            \n            # Check if we have enough data for ATR calculation\n            if len(close) > self.atr_period:\n                # Calculate ATR using tulipy\n                atr_values = tulipy.atr(high, low, close, self.atr_period)\n                if len(atr_values) > 0:\n                    atr = decimal.Decimal(str(atr_values[-1]))\n                    return atr * self.atr_multiplier\n            \n            # Fallback to percentage-based stop if ATR calculation fails\n            return current_price * decimal.Decimal(\"0.01",
		"self.atr_multiplier\n        except Exception as e:\n            self.logger.exception(e, False, f\"Error calculating ATR for {symbol}: {e}\")\n            # Fallback to percentage-based stop\n            return current_price * decimal.Decimal(\"0.01",
		"self.atr_multiplier\n\n    def calculate_r_value(self, position, entry_price, stop_distance):\n        \"",
		"\n        Calculate the R value (initial risk) for the position\n        \"",
		"\n        if position.side is trading_enums.PositionSide.LONG:\n            return entry_price - (entry_price - stop_distance)\n        else:  # SHORT\n            return (entry_price + stop_distance) - entry_price\n\n    def calculate_current_r(self, position, entry_price, current_price, r_value):\n        \"",
		"\n        Calculate current profit/loss in R multiples\n        \"",
		"\n        if r_value == 0:\n            return decimal.Decimal('0')\n            \n        if position.side is trading_enums.PositionSide.LONG:\n            return (current_price - entry_price) / r_value\n        else:  # SHORT\n            return (entry_price - current_price) / r_value\n\n    def calculate_trailing_stop_price(self, position, current_price, stop_distance, current_r):\n        \"",
		"\n        Calculate the new trailing stop price based on ATR and profit tiers\n        \"",
		"\n        # Start with basic trailing stop based on ATR\n        if position.side is trading_enums.PositionSide.LONG:\n            new_stop_price = current_price - stop_distance\n        else:  # SHORT\n            new_stop_price = current_price + stop_distance\n            \n        # Adjust stop based on profit tiers\n        if self.profit_tiers:\n            # Find the highest tier that has been reached\n            highest_tier = None\n            for tier in self.profit_tiers:\n                r_multiple = decimal.Decimal(str(tier[\"r_multiple"
	],
	[
		"lock_percentage"
	],
	[
		"r_multiple"
	],
	[
		"lock_percentage"
	],
	[
		"position_id] = decimal.Decimal('0')\n            \n            # Check each take profit level\n            for i, r_multiple in enumerate(self.partial_take_profit_r_multiples):\n                r_multiple = decimal.Decimal(str(r_multiple))\n                # Check if we've reached this R level and haven't taken profit yet\n                if current_r >= r_multiple:\n                    # Check if we've already taken this profit level\n                    if i >= len(str(self.position_locked_quantities[position_id])):\n                        if i < len(self.partial_take_profit_percentages):\n                            percentage = decimal.Decimal(str(self.partial_take_profit_percentages[i]))\n                            # Calculate quantity to close\n                            quantity_to_close = position.quantity * percentage\n                            \n                            # Create take profit order\n                            order_type = trading_enums.TraderOrderType.SELL_LIMIT if position.side is trading_enums.PositionSide.LONG else trading_enums.TraderOrderType.BUY_LIMIT\n                            side = trading_enums.TradeOrderSide.SELL if position.side is trading_enums.PositionSide.LONG else trading_enums.TradeOrderSide.BUY\n                            \n                            # Calculate take profit price based on R multiple\n                            r_value = self.calculate_r_value(position, position.entry_price, \n                                                            await self.calculate_atr_stop_distance(position.symbol, current_price))\n                            take_profit_price = position.entry_price + (r_value * r_multiple) if position.side is trading_enums.PositionSide.LONG else position.entry_price - (r_value * r_multiple)\n                            \n                            take_profit_order = trading_personal_data.create_order_instance(\n                                trader=self.exchange_manager.trader,\n                                order_type=order_type,\n                                symbol=position.symbol,\n                                current_price=take_profit_price,\n                                quantity=quantity_to_close,\n                                price=take_profit_price,\n                                side=side,\n                                reduce_only=True\n                            )\n                            \n                            await self.trading_mode.create_order(take_profit_order)\n                            \n                            # Update locked quantities\n                            self.position_locked_quantities[position_id] += quantity_to_close\n                            \n                            self.logger.info(f\"Created partial take profit order for {position.symbol}: {quantity_to_close} at {take_profit_price}",
		"except Exception as e:\n            self.logger.exception(e, True, f\"Error checking partial take profits for position {position}: {e}",
		"async def check_break_even_adjustment(self, position, current_r, stop_distance):\n        \"",
		"\n        Check if we should adjust stop to break-even\n        \"",
		"\n        try:\n            if current_r >= self.break_even_r_multiple:\n                # Get existing stop-loss orders\n                existing_sl_orders = [\n                    order for order in self.exchange_manager.exchange_personal_data.orders_manager.get_open_orders(\n                        position.symbol\n                    )\n                    if order.side is not position.side and order.order_type in (\n                        trading_enums.TraderOrderType.STOP_LOSS,\n                        trading_enums.TraderOrderType.STOP_LOSS_LIMIT\n                    )\n                ]\n                \n                # Check if any stop loss is below/above break-even (depending on position side)\n                needs_adjustment = False\n                if position.side is trading_enums.PositionSide.LONG:\n                    for order in existing_sl_orders:\n                        if order.origin_price < position.entry_price:\n                            needs_adjustment = True\n                            break\n                else:  # SHORT\n                    for order in existing_sl_orders:\n                        if order.origin_price > position.entry_price:\n                            needs_adjustment = True\n                            break\n                \n                # Adjust stop loss to break-even if needed\n                if needs_adjustment:\n                    await self.update_stop_loss_order(position, position.entry_price)\n                    self.logger.info(f\"Adjusted stop loss to break-even for {position.symbol}",
		"except Exception as e:\n            self.logger.exception(e, True, f\"Error checking break-even adjustment for position {position}: {e}",
		"async def check_trade_duration(self, position, symbol):\n        \"",
		"\n        Check if trade duration has exceeded maximum and close if needed\n        \"",
		"\n        try:\n            position_id = position.get_id()\n            if position_id not in self.position_entry_times:\n                # Record entry time\n                self.position_entry_times[position_id] = self.exchange_manager.exchange.get_exchange_current_time()\n                return\n                \n            # Check if maximum duration has been exceeded\n            entry_time = self.position_entry_times[position_id]\n            current_time = self.exchange_manager.exchange.get_exchange_current_time()\n            duration_bars = (current_time - entry_time) // self.exchange_manager.exchange_config.get_shortest_time_frame().value\n            \n            if duration_bars > self.max_trade_duration_bars:\n                # Close position\n                order_type = trading_enums.TraderOrderType.SELL_MARKET if position.side is trading_enums.PositionSide.LONG else trading_enums.TraderOrderType.BUY_MARKET\n                side = trading_enums.TradeOrderSide.SELL if position.side is trading_enums.PositionSide.LONG else trading_enums.TradeOrderSide.BUY\n                \n                market_order = trading_personal_data.create_order_instance(\n                    trader=self.exchange_manager.trader,\n                    order_type=order_type,\n                    symbol=symbol,\n                    current_price=decimal.Decimal('0'),  # Market order\n                    quantity=position.quantity,\n                    price=decimal.Decimal('0'),\n                    side=side,\n                    reduce_only=True\n                )\n                \n                await self.trading_mode.create_order(market_order)\n                self.logger.info(f\"Closed position {symbol} due to maximum trade duration exceeded",
		"Clean up tracking data\n                if position_id in self.position_entry_times:\n                    del self.position_entry_times[position_id]\n                if position_id in self.position_max_r_values:\n                    del self.position_max_r_values[position_id]\n                if position_id in self.position_locked_quantities:\n                    del self.position_locked_quantities[position_id]\n        except Exception as e:\n            self.logger.exception(e, True, f\"Error checking trade duration for position {position}: {e}",
		"async def update_stop_loss_order(self, position, new_stop_price):\n        \"",
		"\n        Update the stop-loss order for a position\n        \"",
		"\n        try:\n            # Get existing stop-loss orders for this position\n            existing_sl_orders = [\n                order for order in self.exchange_manager.exchange_personal_data.orders_manager.get_open_orders(\n                    position.symbol\n                )\n                if order.side is not position.side and order.order_type in (\n                    trading_enums.TraderOrderType.STOP_LOSS,\n                    trading_enums.TraderOrderType.STOP_LOSS_LIMIT\n                )\n            ]\n            \n            # Check if existing stop is already at or better than new stop\n            stop_needs_update = True\n            if position.side is trading_enums.PositionSide.LONG:\n                # For long positions, existing stop should be <= new stop\n                for order in existing_sl_orders:\n                    if order.origin_price >= new_stop_price:\n                        stop_needs_update = False\n                        break\n            else:  # SHORT\n                # For short positions, existing stop should be >= new stop\n                for order in existing_sl_orders:\n                    if order.origin_price <= new_stop_price:\n                        stop_needs_update = False\n                        break\n            \n            if not stop_needs_update:\n                return\n            \n            # Cancel existing stop-loss orders\n            for order in existing_sl_orders:\n                await self.trading_mode.cancel_order(order)\n                \n            # Create new stop-loss order\n            order_type = trading_enums.TraderOrderType.STOP_LOSS\n            side = trading_enums.TradeOrderSide.SELL if position.side is trading_enums.PositionSide.LONG else trading_enums.TradeOrderSide.BUY\n            \n            stop_order = trading_personal_data.create_order_instance(\n                trader=self.exchange_manager.trader,\n                order_type=order_type,\n                symbol=position.symbol,\n                current_price=new_stop_price,\n                quantity=position.quantity,\n                price=new_stop_price,\n                side=side,\n                reduce_only=True\n            )\n            \n            await self.trading_mode.create_order(stop_order)\n            \n        except Exception as e:\n            self.logger.exception(e, True, f\"Error updating stop-loss order for position {position}: {e}",
		"classmethod\n    def get_should_cancel_loaded_orders(cls):\n        return True\n\n    async def _set_state(self, cryptocurrency: str, symbol: str, new_state):\n        if new_state != self.state:\n            self.state = new_state\n            self.logger.info(f",
		[
			{
				"state": {
					"self.state.name}": "if new state is not neutral --> cancel orders and create new else keep orders\n            if new_state is not trading_enums.EvaluatorStates.NEUTRAL:\n                # For this mode"
				}
			}
		]
	]
]